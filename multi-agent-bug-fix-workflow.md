# 複数エージェントによるバグ修正ワークフロー

## 概要

このドキュメントは、Claude Code MCP（`mcp__ccm__claude_code`）を使用して複数の専門エージェントを協調させ、効率的にバグを修正するワークフローを記述します。

**対象読者**: このドキュメントはClaude Codeが参照して、複数エージェントによるバグ修正を実行するためのガイドです。

## ワークフローの構成要素

### 1. 調査エージェント（Investigation Agent）
- **役割**: バグの原因調査と修正方法の提案
- **モデル**: Ops
- **成果物**: `bug-investigation-report.md`

### 2. 実装エージェント（Implementation Agent）
- **役割**: 調査結果に基づいた修正の実装
- **モデル**: sonnet
- **成果物**: 実際のコード修正

### 3. レビューエージェント（Review Agent）
- **役割**: 実装された修正のコードレビュー
- **モデル**: Opus
- **成果物**: `code-review-report.md`

### 4. デバッグエージェント（Debug Agent）
- **役割**: 問題発生時のトラブルシューティング
- **モデル**: sonnet（コスト効率を重視）
- **起動条件**: エラー発生時や動作確認失敗時のみ起動
- **タスク例**:
  - 環境状態の確認（プロセス状態、ファイルシステム）
  - エラーログの詳細調査
  - 実行環境の問題特定
  - 簡易的な修正提案

## 詳細なワークフロー

### Phase 0: クリーンアップ

ワークフロー開始前に、前回の実行で生成された成果物ファイルをクリーンアップします。

```bash
# バックアップディレクトリの作成（存在しない場合）
mkdir -p ./backup

# 既存の成果物ファイルを確認
ls -la | grep -E "(bug-investigation-report|code-review-report)\.md"

# 既存ファイルがある場合はバックアップ
if [ -f "bug-investigation-report.md" ]; then
  # ./backupディレクトリにタイムスタンプ付きでバックアップ
  mv bug-investigation-report.md "./backup/bug-investigation-report_$(date +%Y%m%d_%H%M%S).md"
  echo "Backed up bug-investigation-report.md"
fi

if [ -f "code-review-report.md" ]; then
  # ./backupディレクトリにタイムスタンプ付きでバックアップ
  mv code-review-report.md "./backup/code-review-report_$(date +%Y%m%d_%H%M%S).md"
  echo "Backed up code-review-report.md"
fi


# 古いバックアップの自動削除（30日以上前のファイル）
# find ./backup -name "*_report_*.md" -mtime +30 -delete
```

### Phase 1: バグ調査

調査エージェント（Opus）を起動して、バグの原因を分析します：

1. **mcp__ccm__claude_code**ツールを使用
2. **model**: "opus"を指定
3. **プロンプトに含める内容**:
   - ユーザーから提供されたバグの詳細
   - 調査手順（コード読み込み、原因特定、影響分析、修正提案）
   - bug-investigation-report.mdへの出力指示

**出力形式の指定**:
```
# バグ調査レポート
## 問題の概要
## 原因の詳細  
## 影響を受けるファイルと関数
## 推奨される修正方法
## 具体的な修正箇所とコード例
```

返されたプロセスIDを保存します（進捗監視用）。

### Phase 2: 進捗監視

1. **5分間待機**（Bashツールで`sleep 300`を実行）
2. **mcp__ccm__get_claude_result**でプロセスの状態を確認
3. 完了していない場合は、さらに**2分待機**して再確認
4. **bug-investigation-report.md**が作成されているか確認（Readツールで確認）

### Phase 3: 修正実装

実装エージェント（Sonnet）を起動して修正を実装します：

1. **mcp__ccm__claude_code**ツールを使用
2. **model**: "sonnet"を指定
3. **プロンプトに含める内容**:
   - bug-investigation-report.mdを読む指示
   - 具体的な修正の実装指示
   - ビルドコマンドの実行指示
   - 実装完了の報告形式

**重要**: 返されたセッションIDを必ず保存します（Phase 5で再利用するため）。

### Phase 3.5: 動作確認とデバッグ（オプション）

修正実装後、必要に応じて動作確認を実施します。エラーが発生した場合は、デバッグエージェントを起動：

1. **動作確認の実施**（メインエージェントが実行）
   - 修正された機能の基本的な動作テスト
   - エラーが発生した場合、詳細を記録

2. **デバッグエージェントの起動条件**:
   - 動作確認でエラーが発生
   - ビルドは成功したが実行時エラーが発生
   - 環境に起因する問題が疑われる

3. **デバッグエージェントの起動**（条件に該当する場合のみ）:
   ```
   - model: "sonnet"を指定（コスト効率重視）
   - プロンプト例:
     「以下のエラーが発生しました。環境状態を確認し、原因を特定してください：
     [エラー詳細]
     確認項目：
     - 実行中のプロセス状態
     - 関連ファイルの存在確認
     - ログファイルの内容
     - 簡易的な解決策の提案」
   ```

4. **デバッグ結果の活用**:
   - 環境問題の場合：メインエージェントが対処
   - コード問題の場合：実装エージェントに修正を依頼

### Phase 4: コードレビュー

1. **3分待機**（実装完了を待つ）
2. レビューエージェント（Opus）を起動：
   - **mcp__ccm__claude_code**ツールを使用
   - **model**: "opus"を指定
   - **出力形式を明確に指定**:
     - 1行目: COMPLETED または INCOMPLETE
     - 2行目以降: INCOMPLETEの場合のみ、具体的な指摘事項

**重要**: 返されたセッションIDを必ず保存します（再レビューで再利用するため）。

### Phase 5: レビュー指摘修正と再レビューサイクル

1. **2分待機**（レビュー完了を待つ）
2. **code-review-report.md**の1行目を確認
3. **INCOMPLETE**の場合（最大5回まで繰り返し）:
   - 実装エージェントのセッションを**再開**（Phase 3のセッションIDを使用）
   - 指摘事項の修正を指示
   - 2分待機
   - レビューエージェントのセッションを**再開**（Phase 4のセッションIDを使用）
   - 再レビューを指示
   - 2分待機
   - レビュー結果を再確認

**重要**: セッションの再開により、各エージェントは前回のコンテキストを保持したまま作業を継続できます。

### 完了確認

**COMPLETED**の場合:
- バグ修正が完了
- 成果物を確認：
  - bug-investigation-report.md（調査レポート）
  - code-review-report.md（レビュー結果）
  - 修正されたソースコード

**INCOMPLETE**のまま5回を超えた場合:
- 手動介入が必要であることを報告

## タスク管理のベストプラクティス

TodoWriteツールを使用して進捗を管理することを推奨：

1. **バグ調査エージェントの完了確認と調査レポート取得**
2. **実装エージェントによる修正**
3. **修正後の動作確認とテスト**
4. **レビューエージェントによるコードレビュー**
5. **レビュー指摘事項の修正**（必要に応じて）
6. **修正後の再レビュー**（必要に応じて）

各タスクの完了時に状態を更新し、全体の進捗を可視化します。

## エージェント間の連携

### セッション管理

各エージェントのセッションIDを適切に管理することで、効率的な連携が可能：

1. **調査エージェント**: 新規セッション（調査完了後は不要）
2. **実装エージェント**: セッションIDを保持（修正サイクルで再利用）
3. **レビューエージェント**: セッションIDを保持（再レビューで再利用）

**重要なポイント**:
- mcp__ccm__claude_codeの戻り値からsession_idを取得
- 実装エージェントとレビューエージェントのセッションIDは変数に保存
- Phase 5でセッションを再開する際は、保存したsession_idを使用
- これにより、各エージェントは前回のコンテキストを保持したまま作業を継続

## 待機時間の目安

- **調査エージェント**: 5分（初回）、2分（再確認）
- **実装エージェント**: 3分
- **レビューエージェント**: 2分
- **修正サイクル**: 各2分

Bashツールの`sleep`コマンドを使用して待機します（例: `sleep 300`は5分待機）。

## 成功事例

### LockServiceバグ修正の例

1. **問題**: ロックファイル作成時のディレクトリ不在エラー
2. **調査結果**: `acquireFileLock`メソッドでディレクトリ作成処理が不足（新規セッション）
3. **実装**: `fs.mkdir({ recursive: true })`による親ディレクトリ作成（セッションID: 924fab52）
4. **初回レビュー**: INCOMPLETE（改善提案あり）（セッションID: e8387697）
   - コメントの国際化
   - ログ出力の追加
   - 定数の活用
5. **修正対応**: 実装エージェントのセッション再開（924fab52を再利用）
6. **再レビュー**: レビューエージェントのセッション再開（e8387697を再利用）→ COMPLETED

## メリット

1. **専門性の活用**: 各エージェントが特定の役割に集中
2. **品質保証**: 複数の視点からの検証
3. **文書化**: 各フェーズの成果物が自動的に文書化
4. **再現性**: ワークフローが形式化され、再利用可能
5. **並列処理**: 独立したタスクは並行実行可能

## 注意事項

1. **コスト管理**: 複数のOpusエージェントを使用するため、APIコストに注意
   - デバッグエージェントはSonnetを使用してコストを抑制
   - メインエージェントは直接デバッグを行わない
2. **待機時間**: エージェントの処理時間を適切に見積もる
3. **エラーハンドリング**: 各エージェントの失敗に対する対処法を準備
4. **セッション管理**: 各エージェントのsession_idを適切に記録・再利用
5. **クリーンアップ**: 前回の成果物を適切に処理（バックアップまたは削除）
6. **デバッグエージェントの使用**: 
   - 必要な場合のみ起動（常時起動しない）
   - トークン消費を最小限に抑える
   - 環境調査に特化させる

## 拡張可能性

このワークフローは以下のような拡張が可能：

- **テストエージェント**: 修正後の自動テスト実行
- **ドキュメントエージェント**: 変更履歴の自動文書化
- **デプロイエージェント**: 修正の自動デプロイ
- **監視エージェント**: 修正後のシステム監視

## エラー処理のポイント

- **ファイルが見つからない場合**: Readツールのエラーを適切に処理し、報告する
- **タイムアウトの場合**: mcp__ccm__get_claude_resultで状態を確認し、必要に応じて再試行
- **プロセス異常終了の場合**: mcp__ccm__list_claude_processesで状態を確認し、クリーンアップ

このワークフローにより、複雑なバグ修正も体系的かつ効率的に実施できます。